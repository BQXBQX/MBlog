---
title: "å…³äº MapLibre GL çš„ä¸€äº›ä¸œè¥¿"
description: "æœ€è¿‘åœ¨åšä¸€äº›åœ°å›¾çš„å¼€å‘ï¼Œå‘ç°å¤§éƒ¨åˆ†çš„åœ°å›¾çš„å®ç°éƒ½æ˜¯åŸºäº `Leaflet` å®ç°çš„ï¼Œä½†æ˜¯ `Leaflet` æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é—®é¢˜ï¼Œä»–æ˜¯é€šè¿‡ç›´æ¥æ“çºµ `Dom` å®ç°çš„åœ°å›¾çš„æ§åˆ¶å’Œæ¸²æŸ“æ“ä½œçš„æ“ä½œï¼Œå› æ­¤æ— è®ºæ€ä¹ˆä¼˜åŒ–ï¼Œç”¨æˆ·ä½“éªŒéƒ½æ˜¯æå·®çš„ï¼Œäºæ˜¯æˆ‘å°±æ‰¾åˆ°äº†å¦å¤–ä¸€ä¸ªæ–¹æ¡ˆï¼š `MapLibre GL` ã€‚"
pubDate: "2024-08-11T17:44:23.976Z"
heroImage: "/img/Sticky/heroImage.jpg"
---

# å…³äº MapLibre GL çš„ä¸€äº›ä¸œè¥¿

æœ€è¿‘åœ¨åšä¸€äº›åœ°å›¾çš„å¼€å‘ï¼Œå‘ç°å¤§éƒ¨åˆ†çš„åœ°å›¾çš„å®ç°éƒ½æ˜¯åŸºäº `Leaflet` å®ç°çš„ï¼Œä½†æ˜¯ `Leaflet` æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é—®é¢˜ï¼Œä»–æ˜¯é€šè¿‡ç›´æ¥æ“çºµ `Dom` å®ç°çš„åœ°å›¾çš„æ§åˆ¶å’Œæ¸²æŸ“æ“ä½œçš„æ“ä½œï¼Œå› æ­¤æ— è®ºæ€ä¹ˆä¼˜åŒ–ï¼Œç”¨æˆ·ä½“éªŒéƒ½æ˜¯æå·®çš„ï¼Œäºæ˜¯æˆ‘å°±æ‰¾åˆ°äº†å¦å¤–ä¸€ä¸ªæ–¹æ¡ˆï¼š `MapLibre GL` ã€‚

## ç®€ä»‹

å¯¹äº `MapLibre GL` ï¼Œä»–è¿˜æœ‰ä¸€ä¸ªå­ªç”Ÿå…„å¼Ÿ `Mapbox GL` ï¼Œ `Mapbox GL` éå¸¸çš„å¼ºå¤§ï¼Œè€Œä¸”è¿˜æä¾›ç½‘ç»œæœåŠ¡ï¼Œä½†æ˜¯ä»–æ˜¯ä¸å¼€æºçš„ã€‚ ç›¸æ¯”ä¹‹ä¸‹ï¼Œ`MapLibre GL` æ˜¯ä¸€ä¸ªå¼€æºçš„é¡¹ç›®ï¼Œæä¾›äº†ç±»ä¼¼çš„åŠŸèƒ½ï¼Œä½†æ²¡æœ‰ç½‘ç»œæœåŠ¡ï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥å®Œå…¨æ§åˆ¶å’Œè‡ªå®šä¹‰ä½ çš„åœ°å›¾åº”ç”¨ï¼ˆæœ€é‡è¦çš„æ˜¯ä¸è¦çœ‹äººå®¶çš„è„¸è‰²äº† ğŸ‘€ï¼‰ã€‚

`MapLibre GL` æ˜¯ä¸€ä¸ªåŸºäº `Web QL` å®ç°çš„ä¸€ä¸ªåœ°å›¾ç”Ÿæˆåº“ï¼Œæ‰€ä»¥ä»–çš„æ¸²æŸ“çš„é—®é¢˜æ˜¯å®Œå…¨ä¸ç”¨è€ƒè™‘çš„ã€‚ï¼ˆè¿™ä¹Ÿå°±æ„å‘³ç€å†™ä»£ç æ—¶å¯ä»¥æ¯«æ— é¡¾åŠçš„å å±å±±äº† ğŸ¤ªï¼‰ã€‚

OKï¼Œä»‹ç»ä¹Ÿä»‹ç»å®Œäº†ï¼Œä¸‹é¢æˆ‘ä»¬è¿›å…¥å¼€å‘ç¯èŠ‚ã€‚

## `Quick Start`

æŒ‰ç…§å®˜æ–¹æ–‡æ¡£ä¸€æ­¥ä¸€æ­¥æ¥å³å¯ï¼Œè¿™é‡Œä¸åšè¿‡å¤šé™ˆè¿°ï¼Œè¿™é‡Œä¸»è¦è®²ä¸€è®²ç»„ä»¶çš„å°è£…ã€‚

ç”±äºå®˜æ–¹çš„ä»£ç å†™æ³•ååˆ†çš„å¤è€**ğŸ‘¹**ï¼ŒåŒæ—¶ä¸ºäº†åæœŸçš„å…¶ä»–çš„åœ°å›¾çš„ä½¿ç”¨ï¼Œæˆ‘ä»¬å†³å®šå°†ç»„ä»¶å°è£…èµ·æ¥ï¼Œå°†ä»£ç å®ç°è¯­ä¹‰åŒ–åŒæ—¶æš´éœ²å‡ºæ¥ä¸€äº›ç»å¸¸ä½¿ç”¨çš„æ–¹æ³•ä¾¿äº `Quick Start` ï¼ˆè¿™é‡Œå·å·å‘Šè¯‰ä½ ï¼Œæˆ‘ä»¬è¦åšçš„æ˜¯ä¸€ä¸ª `Genshin Map` ğŸ—¾ï¼‰ã€‚ä¸‹é¢æ˜¯å°è£…çš„å‡ ä¸ªæœ€åŸºç¡€çš„æ ·ä¾‹ï¼Œæƒ³å·æ‡’çš„å…„å¼Ÿå¯ä»¥ç›´æ¥ `Copy` ï¼Œå¹¶ä¸”åœ¨ä¸Šé¢æ‰©å±•ï¼Œå†™å‡ºè‡ªå·±æƒ³è¦çš„åœ°å›¾ã€‚

### å°è£…æ ·ä¾‹

ä¸‹é¢æ˜¯ `Map` çš„å°è£…

```tsx
import {
  Children,
  cloneElement,
  forwardRef,
  ReactElement,
  useEffect,
  useRef,
  useState,
} from "react";
import * as maplibreGL from "maplibre-gl";
import "maplibre-gl/dist/maplibre-gl.css";

export interface MapProps extends Omit<maplibreGL.MapOptions, "container"> {
  /**
   * container
   */
  container?: string | HTMLElement;
  /**
   * children element of the map
   */
  children?: ReactElement[] | ReactElement;
  /**
   * transformRequest
   */
  transformRequest: maplibreGL.RequestTransformFunction;
  /**
   * mapInfo, the infomation of this
   */
  mapInfo?: MapInfo;
  /**
   * layer the layer of the map
   */
  layers?: maplibreGL.LayerSpecification[];
  /**
   * source the source of the map
   */
  source?: maplibreGL.SourceSpecification;
}

export interface MapInfo {
  map_version: string;
  min_zoom: number;
  max_zoom: number;
  origin: [number, number];
  center: [number, number];
}

export const Map = forwardRef<{}, MapProps>(
  (
    {
      container,
      children,
      transformRequest,
      mapInfo,
      layers,
      source,
      style,
      ...rest
    },
    ref
  ) => {
    const mapContainer = useRef<HTMLDivElement>(null);
    const glMap = useRef<maplibreGL.Map | null>(null);
    const [map, setMap] = useState<maplibreGL.Map | null>(null);

    useEffect(() => {
      if (mapContainer.current) {
        glMap.current = new maplibreGL.Map({
          container: container ?? mapContainer.current, // Reference to the map container
          style: {
            version: 8, // Style specification version
            sources: source ? { source } : {},
            layers: layers ?? [],
          },
          transformRequest: transformRequest,
          ...rest,
        });

        glMap.current.on("load", () => {
          setMap(glMap.current);
        });

        if (ref) {
          (ref as React.MutableRefObject<maplibreGL.Map>).current =
            glMap.current;
        }
      }
      // Cleanup function to remove the map instance and event listeners when the component unmounts
      return () => {
        if (glMap.current) glMap.current.remove(); // Remove the map instance
      };
    }, [container, transformRequest, mapInfo, layers, source, rest]);

    return (
      <>
        <div
          style={{ background: "black", width: "100vw", height: "100vh" }}
          ref={mapContainer}
        >
          {map &&
            children &&
            Children.map(children, (child) =>
              cloneElement(child, { currentMap: map })
            )}
        </div>
      </>
    );
  }
);

Map.displayName = "Map";
```

ä¸‹é¢æ˜¯ `Layer` çš„å°è£…

```tsx
import * as maplibreGL from "maplibre-gl";
import React, { useEffect } from "react";

export interface LayerProps {
  /**
   * currentMap, give me the Map, i will bind this layout to this map
   */
  currentMap?: maplibreGL.Map;
  /**
   * layout options
   */
  layerOptions: maplibreGL.LayerSpecification;
  /**
   * isSourceLoaded, source loaded the layer will add
   */
  isSourceLoaded?: boolean;
}

export type LayerOptions = maplibreGL.LayerSpecification;

export const Layer = React.forwardRef<
  maplibreGL.LayerSpecification,
  LayerProps
>(({ currentMap, layerOptions, isSourceLoaded }, ref) => {
  useEffect(() => {
    if (!currentMap) return;

    if (isSourceLoaded) {
      currentMap.addLayer({ ...layerOptions });

      if (ref) {
        (ref as React.MutableRefObject<maplibreGL.LayerSpecification>).current =
          layerOptions;
      }
    }

    return () => {
      if (currentMap.getLayer(layerOptions.id))
        currentMap.removeLayer(layerOptions.id);
    };
  }, [currentMap, layerOptions, isSourceLoaded]);

  return null;
});

Layer.displayName = "Layer";
```

ä¸‹é¢æ˜¯ `Source` çš„å°è£…

```tsx
import * as maplibreGL from "maplibre-gl";
import {
  Children,
  cloneElement,
  forwardRef,
  ReactElement,
  useEffect,
  useState,
} from "react";

export interface SourceProps {
  /**
   * currentMap, give me the map, i will bind this source to this map
   */
  currentMap?: maplibreGL.Map;
  /**
   * source options
   */
  sourceOptions: maplibreGL.SourceSpecification;
  /**
   * source Id
   */
  sourceId: string;
  /**
   * children, the children element of  sourceProps
   */
  children?: ReactElement | ReactElement[];
}

export type SourceOptions = maplibreGL.SourceSpecification;

export const Source = forwardRef<maplibregl.SourceSpecification, SourceProps>(
  ({ currentMap, sourceOptions, sourceId, children }, ref) => {
    const [isSourceLoaded, setIsSourceLoaded] = useState<boolean>(false);
    useEffect(() => {
      if (!currentMap) return;

      if (!currentMap.getSource(sourceId)) {
        currentMap.addSource(sourceId, sourceOptions);

        // Listen for the source being added
        currentMap.on("sourcedata", function (e) {
          if (e.sourceId === sourceId && e.isSourceLoaded) {
            setIsSourceLoaded(true);
          }
        });
      }

      if (ref) {
        (
          ref as React.MutableRefObject<maplibreGL.SourceSpecification>
        ).current = sourceOptions;
      }

      return () => {
        if (currentMap.getSource(sourceId)) currentMap.removeSource(sourceId);
      };
    }, [currentMap, sourceOptions, sourceId]);

    return (
      <>
        {sourceId &&
          children &&
          isSourceLoaded &&
          Children.map(children, (child) => {
            const { layerOptions } = child.props;
            const newLayerOptions = { ...layerOptions, source: sourceId };
            return cloneElement(child, {
              currentMap: currentMap,
              isSourceLoaded: isSourceLoaded,
              layerOptions: newLayerOptions,
            });
          })}
      </>
    );
  }
);

Source.displayName = "Source";
```

â€¦ è¿˜æœ‰ `Marker` ï¼Œ `Control` ã€‚ï¼ˆğŸŒš æ‡’äº†å°±æ²¡å†™ï¼‰

é€šè¿‡è¿™äº›å°è£…ï¼Œæˆ‘ä»¬å¯ä»¥æ›´åŠ è½»æ¾åœ°ä½¿ç”¨ `MapLibre GL` åˆ›å»ºå’Œç®¡ç†åœ°å›¾ç»„ä»¶ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘å°†å±•ç¤ºä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œæ¥å…·ä½“è®²ä¸€è®²å¦‚ä½•ä½¿ç”¨è¿™äº›å°è£…çš„ç»„ä»¶æ¥æ„å»ºä¸€ä¸ªåŸºæœ¬çš„åœ°å›¾åº”ç”¨ã€‚

```tsx
import {
  Map,
  Layer,
  Source,
  type MapInfo,
  type LayerOptions,
  type SourceOptions,
} from "maplibre-components";

export const Main = () => {
  const maxZoomLevel = 6;
  const minZoomLevel = 2;
  const defaultZoomLevel = 2;
  const layer: LayerOptions = {
    id: "raster-~~layer~~", // Layer ID
    type: "raster", // Layer type
    source: "tiles", // Source ID defined above
    minzoom: minZoomLevel - 1, // Minimum zoom level for this layer
    maxzoom: maxZoomLevel + 1, // Layer's maximum zoom level (one more than map's maxZoom)
  };

  const mapInfo: MapInfo = {
    map_version: "xxx",
    min_zoom: -3,
    max_zoom: 0,
    origin: [xxx, xxx],
    center: [xxx, xxx], // ç›¸å¯¹äºoriginçš„åç§»é‡
  };

  const source: SourceOptions = {
    type: "raster", // Specify the type as raster for raster tiles
    tiles: [
      `xxx`, // URL template for your tile layer
    ],
    tileSize: 256, // Size of the tiles
  };

  return (
    <Map
      mapInfo={mapInfo}
      maxZoom={maxZoomLevel}
      minZoom={minZoomLevel}
      zoom={defaultZoomLevel}
      renderWorldCopies={false}
      transformRequest={transformRequest}
    >
      <Source sourceOptions={source} sourceId="tiles">
        <Layer layerOptions={layer}></Layer>
      </Source>
    </Map>
  );
};
```

è¿™å°±æ˜¯ä¸Šæ–‡çš„å…¨éƒ¨å†…å®¹äº†ï¼Œå¦‚æœæœ‰ä»»ä½•çš„ç–‘é—®éƒ½å¯ä»¥åœ¨è¯„è®ºåŒºç•™è¨€å“¦ã€‚ï¼ˆå·å·å‘Šè¯‰ä½  `MapLibre GL` æ˜¯ä¸æ”¯æŒè‡ªå®šä¹‰åœ°å›¾çš„ï¼Œè‰¹ï¼Œå½“æ—¶å› ä¸ºè¿™ä¸ªè¸©å‘è¸© ğŸ´ äº†ï¼‰ã€‚

![end](/img/MapLibre/Untitled.png)
